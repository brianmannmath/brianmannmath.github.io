<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Math and Programming]]></title>
  <link href="http://brianmannmath.github.io/atom.xml" rel="self"/>
  <link href="http://brianmannmath.github.io/"/>
  <updated>2014-02-13T16:51:27-07:00</updated>
  <id>http://brianmannmath.github.io/</id>
  <author>
    <name><![CDATA[Brian Mann]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Math Is Hard]]></title>
    <link href="http://brianmannmath.github.io/blog/2014/02/13/math-is-hard/"/>
    <updated>2014-02-13T16:44:35-07:00</updated>
    <id>http://brianmannmath.github.io/blog/2014/02/13/math-is-hard</id>
    <content type="html"><![CDATA[<p>(This isn’t aimed at anyone I know, more at people giving out grants or university administration or job interviewers.)</p>

<p>Something I find silly and infuriating: when people equate knowing some math well with being able to explain it well to a lay-person, or when someone gets upset that you can’t explain math to them in simple terms. </p>

<p>Think about it like this: suppose you’ve only learned (very) basic French and a friend is trying to explain some part of a complicated French novel or poem. There’s an idiom you don’t really understand because English doesn’t have anything similar. Of course, you would accept an English approximation of the idiom, even if you don’t understand exactly what it means. And if you really wanted to know you would learn more French. But you probably wouldn’t get upset at your friend; you would realize that it’s impossible for your friend to explain exactly what it means without speaking in French.</p>

<p>Math is a very complicated language with lots of idioms that can’t be explained in English. I’M NOT GOING TO BE ABLE TO GIVE YOU A GOOD IDEA  (OR REALLY ANY IDEA) OF WHAT I’VE SPENT THE LAST 3+ YEARS WORKING ON UNLESS YOU LEARN SOME MATH.</p>

<p>I’m tired of people asserting that I “should” be able to explain my research. How would you explain <script type="math/tex">\mathbb{R}</script>-trees? Out(<script type="math/tex">F_N</script>)? I can talk about geometric group theory at a low level all day, but that describes the research of hundreds (thousands) of people, not <em>my</em> research. Suggestions?</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Representation Stability Part 1]]></title>
    <link href="http://brianmannmath.github.io/blog/2014/01/23/representation-stability/"/>
    <updated>2014-01-23T18:40:25-07:00</updated>
    <id>http://brianmannmath.github.io/blog/2014/01/23/representation-stability</id>
    <content type="html"><![CDATA[<p>At the Joint Math Meetings in January 2014, I saw <a href="http://www.math.uchicago.edu/~farb/">Benson Farb</a> give a talk about some very beautiful, very cutting-edge mathematics called <em>representation stability.</em> It’s still very new (the <a href="http://arxiv.org/pdf/1008.1368.pdf">first paper</a> is from 2013), but it’s a very powerful tool that should prove useful in both purely mathematical and applied settings (namely physics). </p>

<p>Before I talk about respresentation stability, I should talk about the notion of <em>stability.</em> The word stability is used in many different settings, but I will define precisely what I mean here. </p>

<h3 id="stability">Stability</h3>

<p>Let $X$ be a sequence of spaces </p>

<script type="math/tex; mode=display">X_0 \rightarrow X_1 \rightarrow X_2 \rightarrow \cdots</script>

<p>For our purposes, they will normally be groups or manifolds and the maps will be group homomorphisms (usually injective) or continuous maps. Any category will do though. Let’s call the category where $X$ lives $\mathcal{C}$.</p>

<p>Let $F$ be a functor from $\mathcal{C}$ to another category $\mathcal{D}$. We say that $X$ is <em>stable</em> with respect to $F$ if, for some $n &gt; 0$, we have $F(X_i) \cong F(X_{i+1})$ for all $i &gt; n$. In other words, the maps in the sequence $F(X) = $</p>

<script type="math/tex; mode=display">F(X_0) \rightarrow F(X_1) \rightarrow F(X_2) \rightarrow \cdots</script>

<p>are eventually isomorphisms. This is a very general concept, and there isn’t much one can say about general stability (there are just too many categories and functors!). However, there are some very special functors that mathematicians care about. </p>

<h3 id="homology">Homology</h3>

<p>Homology, in general, is an advanced topic more suited to a graduate course in algebraic topology. The wonderful thing about homology, though, is that while the technical details are opaque to those without the required background, one can give a fairly complete intuitive definition without too much pain and suffering. I’m writing this section for the reader who knows little-to-nothing about homology - if you’ve taken an algebraic topology course, feel free to skip it. </p>

<h4 id="okay-so-what-it-is">Okay, so what it is?</h4>

<p>(Very) roughly speaking, homology is a measurement of a toplogical space’s inability to be collapsed to a point. Before I get into any details, let’s look at some examples:</p>

<p>Consider $S^1$, the circle. I encourage the reader not to think about the circle as “living in” the the plane or any larger space, but to think about it as an object on its own. $S^1$ cannot be collapsed to a point - intuitively speaking, one cannot  deform $S^1$ to a point without cutting it somewhere (remember, $S^1$, is not living in the plane. It <em>is</em> true that one can collpase the circle in $\mathbb{R}^2$ to a point in $\mathbb{R}^2$). </p>

<p>(Actually, for the industrious reader, if one thinks of $S^1$ at the unit interval $[0,1]$ with $0$ and $1$ identified, the result that $S^1$ is not homotopy equivalent to a point can be made precise using only freshman calculus!) </p>

<p>Similarly, the 2-sphere $S^2$ cannot be deformed to a point. But if we look more closely, we see that the “holes” in these two spaces are different. Indeed, any 1-dimensional loop on $S^2$ <em>can</em> be deformed to a point, but nevertheless, there is still a “hole” in $S^2$ which prevents us from continuously deforming it to a point.</p>

<p>We need a way to measure these differences quantitatively; after all, this is mathematics! That’s what homology does. </p>

<p>The homology of a space $X$ is a collection of $\mathbb{Q}$-vector spaces $H_i(X,\mathbb{Q})$ for <script type="math/tex">i = 0,1,2, \ldots</script>. The $\mathbb{Q}$ isn’t really important here; indeed, it’s possible to replace $\mathbb{Q}$ with any other field or ring (in which case, you get a module instead of a vector space). But I assume most of my readers are comfortable with vector spaces at least, so we’ll work over $\mathbb{Q}$. </p>

<p>Furthermore, if <script type="math/tex">f: X \rightarrow Y</script> is a continuous map, then it induces a linear map <script type="math/tex">f_*: H_i(X,\mathbb{Q}) \rightarrow H_i(Y,\mathbb{Q})</script> for all $i$. In other words, each $H_i(–,\mathbb{Q})$ is a functor from the category of topological spaces to the category of vector spaces over $\mathbb{Q}$! The nice thing about this is that homology is an invariant: that is, if $X \cong Y$, then <script type="math/tex">H_i(X,\mathbb{Q}) \cong H_i(Y,\mathbb{Q})</script>. So, if we want to tell if two spaces are different, we can (in theory) compute their homology and see if they are different dimensions! </p>

<p>Let’s return to our examples to see what homology does. I haven’t told you how one actually defines the vector spaces $H_i(X,\mathbb{Q})$ yet, so we can’t do any computations, but I can tell you the answers.</p>

<p>For a point,</p>

<script type="math/tex; mode=display">H_i(pt,\mathbb{Q}) = 0</script>

<p>for all $i$. For <script type="math/tex">S^1</script>,</p>

<script type="math/tex; mode=display">H_1(S^1, \mathbb{Q}) = \mathbb{Q}</script>

<p>which tell us that <script type="math/tex">S^1</script> cannot be deformed to a point. What about $S^2$? One can compute </p>

<script type="math/tex; mode=display">H_1(S^2,\mathbb{Q}) = 0</script>

<p>which tells us that $S^2$ cannot be deformed to $S^1$. Furthermore </p>

<script type="math/tex; mode=display">H_2(S^2,\mathbb{Q}) = \mathbb{Q}</script>

<p>so $S^2$ cannot be deformed to a point.  </p>

<h3 id="what-about-stability">What about stability?</h3>

<p>Remember, stability is a property of a sequence of spaces with respect to a functor, and now we have a handful of functors to play with! Let’s go back to the original setting: a sequence $X =$</p>

<script type="math/tex; mode=display">X_0 \rightarrow X_1 \rightarrow X_2 \rightarrow \cdots</script>

<p>of spaces. We say that $X$ is <em>homologically stable</em> if for every $i &gt; 0$, $X$ is stable with respect to $H_i(-,\mathbb{Q})$. Note that the point at which the seqeunce</p>

<script type="math/tex; mode=display">H_i(X_0,\mathbb{Q}) \rightarrow H_i(X_1, \mathbb{Q}) \rightarrow H_i(X_2, \mathbb{Q}) \rightarrow \cdots</script>

<p>stabilizes might depend on $i$.</p>

<h3 id="thats-enough-for-one-sitting-next-time">That’s enough for one sitting. Next time?</h3>

<p>In part 2, I want to discuss a motivating example where homological stability fails but “should” hold, and explain what respresentation stability is, and how it solves our problem.</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Using Lapply to Import Files to R]]></title>
    <link href="http://brianmannmath.github.io/blog/2014/01/20/using-lapply-to-import-files-to-r/"/>
    <updated>2014-01-20T18:22:42-07:00</updated>
    <id>http://brianmannmath.github.io/blog/2014/01/20/using-lapply-to-import-files-to-r</id>
    <content type="html"><![CDATA[<p>One of the trickest parts, for me, of learning a new language is figuring out how it interacts with the outside world (i.e. the rest of your computer). This post might seem dumb to people with even a few months of R experience, but I decided to post it anyway, if only to document my learning process. When I started learning R I was given the following task: you have a directory which stores several .csv files, say 001.csv, 002.csv, … 332.csv and a task which requires you to do something with all of them. The task itself is irrelevant, so we’ll ignore it. How do you import all these files efficiently? </p>

<p>My first instinct (probably because the file names were all numbers) was to loop over all of the names. But, of course, I needed to ensure all of the zeroes were still there. So I needed to do something like</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
<span class="line-number">3</span>
<span class="line-number">4</span>
<span class="line-number">5</span>
<span class="line-number">6</span>
</pre></td><td class="code"><pre><code class="r"><span class="line"><span class="kr">for</span> <span class="p">(</span>id <span class="kr">in</span> <span class="m">1</span><span class="o">:</span><span class="m">332</span><span class="p">){</span>
</span><span class="line">    num <span class="o">=</span> formatC<span class="p">(</span>id<span class="p">,</span> width <span class="o">=</span> <span class="m">3</span><span class="p">,</span> flag <span class="o">=</span> <span class="s">&quot;0&quot;</span><span class="p">)</span> <span class="c1">#creates a 3-digit string representing an integer</span>
</span><span class="line">    D <span class="o">&lt;-</span> paste<span class="p">(</span>directory<span class="p">,</span> paste<span class="p">(</span>num<span class="p">,</span> <span class="s">&quot;csv&quot;</span><span class="p">,</span> sep <span class="o">=</span> <span class="s">&quot;.&quot;</span><span class="p">),</span> sep <span class="o">=</span> <span class="s">&quot;/&quot;</span><span class="p">)</span> <span class="c1">#D is the file name string</span>
</span><span class="line">    x <span class="o">&lt;-</span> read.csv<span class="p">(</span>D<span class="p">)</span>
</span><span class="line">    data <span class="o">&lt;-</span> c<span class="p">(</span>data<span class="p">,</span>x<span class="p">)</span> <span class="c1">#data is a list of all the data frames we needed to import</span>
</span><span class="line"><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>But that’s gross, and in any case, it doesn’t work if the names of the files don’t live in some list you can easily access (like 1:332). Recall, though, that R has some nice “map” functions, namely ‘lapply’. Also</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="r"><span class="line">dir<span class="p">()</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>returns a list of the names of files in the working directory. So</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
<span class="line-number">2</span>
</pre></td><td class="code"><pre><code class="r"><span class="line">setwd<span class="p">(</span><span class="s">&quot;where your .csv files are&quot;</span><span class="p">)</span>
</span><span class="line">data <span class="o">&lt;-</span> lapply<span class="p">(</span>dir<span class="p">(),</span>read.csv<span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>returns a data frame consisting of all the .csv files you needed to import. Voila. </p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Who Am I?]]></title>
    <link href="http://brianmannmath.github.io/blog/2014/01/18/first-post/"/>
    <updated>2014-01-18T14:41:34-07:00</updated>
    <id>http://brianmannmath.github.io/blog/2014/01/18/first-post</id>
    <content type="html"><![CDATA[<p>My name is Brian Mann, and I’m a mathematician turned programmer/computer scientist.</p>

<p>Currently, I’m a doctoral student that the University of Utah doing research in the field of <a href="http://en.wikipedia.org/wiki/Geometric_group_theory">geometric group theory</a> under the advisement of <a href="http://en.wikipedia.org/wiki/Mladen_Bestvina">Mladen Bestvina</a>. Specifically, I study the outer automorphism group of finite rank free groups, and also the dynamics of group actions on $\mathbb{R} \mbox{-trees}$. I’ve written/co-authored two papers: <a href="http://arxiv.org/abs/1212.2986">Hyperbolicity of the Cyclic Splitting Complex</a> and <a href="http://arxiv.org/abs/1311.1771">Constructing Non-uniquely Ergodic Arational Trees</a>. (<em>A word of warning: these papers are not for beginners. They require basic knowledge about standard tools in geometric group theory, especially <a href="http://en.wikipedia.org/wiki/Bass-Serre">Bass-Serre Theory</a>. I will likely talk more about the background required in later posts.</em>)</p>

<p>For an overview of what I’ve been thinking about recently, you might want to look at slides from a recent <a href="https://github.com/brianmannmath/JointMathMeetings/blob/master/JMM_talk.pdf">talk</a> I gave at the Joint Math Meetings.</p>

<p>I love mathematics. But for various reasons (which I will likely write about in the future) I have decided not to pursue a career in academics. I also love computers. I’ve always been fascinated by them and enjoyed all of the little coding projects I’ve needed to do in my career as a mathematician, but have never had time to <em>really</em> learn to code. Now that I’m graduating, I’ve decided to change that. I’m teaching myself Python, R, Haskell, and C++ and trying to get a job in the Seattle area which uses my mathmematical knowledge/skills to computer-related applications (data science, crytpography, software development, etc…).</p>

<p>This blog is mainly to document my transformation from pure mathematician to a hybrid mathematician/computer-scientist/programmer. Although I am currently focusing on learning Python and R (which I feel will be most useful in my job hunt), I’m hoping to post a lot about Haskell. Which brings me to my next point…</p>

<h4 id="i-fucking-love-haskell">I fucking love Haskell.</h4>

<p>Look at this:</p>

<div class="bogus-wrapper"><notextile><figure class="code"><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class="line-number">1</span>
</pre></td><td class="code"><pre><code class="hs"><span class="line"><span class="nf">fibs</span> <span class="ow">=</span> <span class="mi">1</span><span class="kt">:</span><span class="mi">1</span><span class="kt">:</span><span class="n">zipWith</span> <span class="p">(</span><span class="o">+</span><span class="p">)</span> <span class="n">fibs</span> <span class="p">(</span><span class="n">tail</span> <span class="n">fibs</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure></notextile></div>

<p>I won’t lie and say this line of code made me fall in love with Haskell, because that’s not true. But it’s certainly one of the most beautiful lines of code I’ve ever seen. I fell in love with Haskell when a good friend (a hacker-turned-algebraic geometer-turned-computer security expert) told me about it. A language based on category theory, you say? Yes please. </p>

<p>Let me explain. I know <em>a lot</em> of category theory. I spent much of my undergrad at the University of Michigan taking graduate level math classes in algebraic geometry. And algebraic geometers <em>love</em> category theory. Why? Because it’s an <em>incredibly expressive language</em> which allows mathematicians to phrase difficult questions in simple, elegant terms. Sound familiar?</p>

<p>When I learned about Haskell, I didn’t know much about programming. But I knew enough to guess at the expressive power of a language based on categorical ideas. At the time, I poked around <a href="http://learnyouahaskell.com/">Learn you a Haskell</a> a bit, but never made any real progress; as an undergraduate taking graduate level mathematics and who was <em>sure</em> he wanted to go into academics, the only real motivation I had to learn Haskell was curiousity. Now I have quite a bit more. </p>

<p>I love Haskell for the same reason I love mathematics. It’s beautiful. Expressive. Powerful. Working in Haskell teaches me to think in different ways about programming. And perhaps one of the reasons I like it so much is because it’s so <em>familiar</em>. It feels like mathematics, because it is mathematics.</p>

<p>Anecdote: I was curious about what a monad was, so naturally I went to <a href="http://en.wikipedia.org/wiki/Monad_(functional_programming)">the wikipedia page</a>. Admittedly, I was confused. Programmers think about things a little differently than mathematicians. So I went to <a href="http://en.wikipedia.org/wiki/Monad_(category_theory)">this wikipedia page</a> and learned what a monad was in category theory. And everything made sense. </p>

<h4 id="so-whats-this-blog-for-anyways">So what’s this blog for anyways?</h4>

<p>My goal here is simple. I want to tell people about cool things I’ve learned and am learning. I want people to know that high-level mathematics isn’t scary. It’s beautiful and fun, just like Haskell. I want people to be curious and ask questions about what I post. I want to force myself to explain things in simple terms so I understand them better myself.</p>

]]></content>
  </entry>
  
</feed>
